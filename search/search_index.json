{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CodeISM Docs The goal of this project is to share the CodeISM (IITISM Coding Society) resources in a neat and concised manner, all at one place. Students may find it helpful for future references and to revise things taught in meets in a fast and efficient way. Students are advised to follow the classes well and read the docs sincerely. Navigation Home Main Page Navigation Number Theory Basics Binary Exponentiation Dynamic Programming Knapsack LIS and LCS How to Contribute? General Information This website (articles, design, ...) is developed via Github . Note that only the students of IIT(ISM) can contribute to the project . Generated pages are compiled and published at https://codeism-community.github.io/docs . In order to make contribution consider the following steps: Fork this repository. Modify the files, articles, etc (except the configuration and site specific files) Make a commit and push to your forked repository. Create a pull-request by clicking the Compare & pull request button. Somebody from the core team will look over the changes. This might take a few hours/days. If you're making a new article or moving existing one to a different place, please make sure that your changes are reflected in The list of all articles in navigation.md . (The navigation list should be in proper format) Syntax We use Markdown for the articles, and use the Material for MkDocs to render the Markdown articles into HTML. For advanced Markdown features of Material for MkDocs see their reference pages , like: Math formulas with MathJax Notice that you need to have an empty line before and after a $$ math block. Code blocks for code snippets. However not everything of the features should be used, and some of the features are not enabled or require a paid subscription. By default the first header ( # header ) will be also the HTML title of the article. Adding Content Try to add the content matter of the topic in a clear and consise form. Things should not be repeated and if external sources are required to be referenced for the topic, then references should be added to the end of the file. There should only be 1 Heading on the article and all the subheadings should match directly with the heading and the flow should be simple. Approaches should be discussed briefly from the naive to the most optimised and expamples should be given as and when required. Adding Problems Try to add problems in ascending order of their difficulty. If you don't have enough time to do so, still add the problem. Lets hope that the next person will sort them accordingly. Local development You can render the pages locally. All you need is Python, with the installed mkdocs-material package. $ git clone https://github.com/codeism-community/docs.git && cd docs $ pip install \\ mkdocs \\ mkdocs-material \\ pymdown-extensions \\ mkdocs-include-markdown-plugin \\ mkdocs-git-committers-plugin-2 \\ mkdocs-literate-nav $ mkdocs serve","title":"Main Page"},{"location":"#welcome-to-codeism-docs","text":"The goal of this project is to share the CodeISM (IITISM Coding Society) resources in a neat and concised manner, all at one place. Students may find it helpful for future references and to revise things taught in meets in a fast and efficient way. Students are advised to follow the classes well and read the docs sincerely.","title":"Welcome to CodeISM Docs"},{"location":"#navigation","text":"Home Main Page Navigation Number Theory Basics Binary Exponentiation Dynamic Programming Knapsack LIS and LCS","title":"Navigation"},{"location":"#how-to-contribute","text":"","title":"How to Contribute?"},{"location":"#general-information","text":"This website (articles, design, ...) is developed via Github . Note that only the students of IIT(ISM) can contribute to the project . Generated pages are compiled and published at https://codeism-community.github.io/docs . In order to make contribution consider the following steps: Fork this repository. Modify the files, articles, etc (except the configuration and site specific files) Make a commit and push to your forked repository. Create a pull-request by clicking the Compare & pull request button. Somebody from the core team will look over the changes. This might take a few hours/days. If you're making a new article or moving existing one to a different place, please make sure that your changes are reflected in The list of all articles in navigation.md . (The navigation list should be in proper format)","title":"General Information"},{"location":"#syntax","text":"We use Markdown for the articles, and use the Material for MkDocs to render the Markdown articles into HTML. For advanced Markdown features of Material for MkDocs see their reference pages , like: Math formulas with MathJax Notice that you need to have an empty line before and after a $$ math block. Code blocks for code snippets. However not everything of the features should be used, and some of the features are not enabled or require a paid subscription. By default the first header ( # header ) will be also the HTML title of the article.","title":"Syntax"},{"location":"#adding-content","text":"Try to add the content matter of the topic in a clear and consise form. Things should not be repeated and if external sources are required to be referenced for the topic, then references should be added to the end of the file. There should only be 1 Heading on the article and all the subheadings should match directly with the heading and the flow should be simple. Approaches should be discussed briefly from the naive to the most optimised and expamples should be given as and when required.","title":"Adding Content"},{"location":"#adding-problems","text":"Try to add problems in ascending order of their difficulty. If you don't have enough time to do so, still add the problem. Lets hope that the next person will sort them accordingly.","title":"Adding Problems"},{"location":"#local-development","text":"You can render the pages locally. All you need is Python, with the installed mkdocs-material package. $ git clone https://github.com/codeism-community/docs.git && cd docs $ pip install \\ mkdocs \\ mkdocs-material \\ pymdown-extensions \\ mkdocs-include-markdown-plugin \\ mkdocs-git-committers-plugin-2 \\ mkdocs-literate-nav $ mkdocs serve","title":"Local development"},{"location":"index_body/","text":"Welcome to CodeISM Docs The goal of this project is to share the CodeISM (IITISM Coding Society) resources in a neat and concised manner, all at one place. Students may find it helpful for future references and to revise things taught in meets in a fast and efficient way. Students are advised to follow the classes well and read the docs sincerely.","title":"Welcome to CodeISM Docs"},{"location":"index_body/#welcome-to-codeism-docs","text":"The goal of this project is to share the CodeISM (IITISM Coding Society) resources in a neat and concised manner, all at one place. Students may find it helpful for future references and to revise things taught in meets in a fast and efficient way. Students are advised to follow the classes well and read the docs sincerely.","title":"Welcome to CodeISM Docs"},{"location":"navigation/","text":"Home Main Page Navigation Number Theory Basics Binary Exponentiation Dynamic Programming Knapsack LIS and LCS","title":"Navigation"},{"location":"dp/knapsack/","text":"Knapsack Introduction Dynamic Programming(DP in short) is an algorithmic approach which deals with the optimal answer for every possible case of a problem. When with brute-force, the time complexity of some algorithms may exceed the limits, DP comes to our rescue. Types Optimal Sub-structure (when there is a global optimal answer to be found) Overlapping Subproblem (when there is a subproblem which is required to compute again and again) Some important terms State - The dependency list of the function to compute Transition - The formula by which we calculate new states from pre-calculated states Base Condition - The condition which stops further calculation of states Target - The final state which is needed Knapsack Knapsack is a classic problem of DP which revolves around making choices for an element to be taken or not. We will cover the whole knapsack starting from scratch. Problem You are given an array $W$ of $n$ numbers representing weights of objects. You have to compute whether it is possible to make target weight $K$ from the given weights. A naive recursive $O(2^n)$ solution to this problem would be to recurse for all possible subsets of the given weights. bool knapsack ( int index , int n , vector < long long > & W , long long K ) { if ( index >= n ) return K == 0 ; else if ( K == 0 ) return true ; if ( W [ index ] <= K ) { return knapsack ( index + 1 , n , W , K - W [ index ]) | knapsack ( index + 1 , n , W , K ); } else { return knapsack ( index + 1 , n , W , K ); } } Solution using DP We can observe that using recursion, the same subtree is calculated multiple times. This repetition can be avoided if the results are stored for every state. This is called Memoization . Let's declare a 2D boolean vector $dp[i][j]$ which will store whether it is possible to make target weight $j$ from the first $i$ weights. $$ dp[i][j] = \\begin{cases} 1 &\\text{if possible} \\\\ 0 &\\text{if not} \\end{cases} $$ $$ dp[i][j] = dp[i-1][j-W[i]] | dp[i-1][j] $$ Implementation The memoization solution $O(n\\times K)$ can be written easily by a few lines of code in the original recursive function. memset ( dp , -1 , sizeof dp ); bool knapsack ( int index , int n , vector < long long > & W , long long K ) { if ( index >= n ) return K == 0 ; else if ( K == 0 ) return true ; if ( dp [ index ][ K ] != -1 ) return dp [ index ][ K ]; if ( W [ index ] <= K ) { return dp [ index ][ K ] = knapsack ( index + 1 , n , W , K - W [ index ]) | knapsack ( index + 1 , n , W , K ); } else { return dp [ index ][ K ] = knapsack ( index + 1 , n , W , K ); } } Another approach for DP is the iterative approach. bool dp [ n + 1 ][ K + 1 ]; long long knapsack ( int n , long long K , vector < long long > & W ) { dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( j >= W [ i ]) { dp [ i ][ j ] = dp [ i -1 ][ j ] | dp [ i -1 ][ j - W [ i ]]; } else { dp [ i ][ j ] = dp [ i -1 ][ j ]; } } } } Extended Problems What if every object has a value $V_i$ associated to it and your task is to maximize the value? Solve if $K$ target may not have to be fullfilled while maximizing the value. Now if the target weight always be only a multiple of $K$ , then finad the maximum sum of values. Practice Problems Atcoder - Frog CSES - Book Shop Atcoder - Vacations Codeforces - Boredom","title":"Knapsack"},{"location":"dp/knapsack/#knapsack","text":"","title":"Knapsack"},{"location":"dp/knapsack/#introduction","text":"Dynamic Programming(DP in short) is an algorithmic approach which deals with the optimal answer for every possible case of a problem. When with brute-force, the time complexity of some algorithms may exceed the limits, DP comes to our rescue.","title":"Introduction"},{"location":"dp/knapsack/#types","text":"Optimal Sub-structure (when there is a global optimal answer to be found) Overlapping Subproblem (when there is a subproblem which is required to compute again and again)","title":"Types"},{"location":"dp/knapsack/#some-important-terms","text":"State - The dependency list of the function to compute Transition - The formula by which we calculate new states from pre-calculated states Base Condition - The condition which stops further calculation of states Target - The final state which is needed","title":"Some important terms"},{"location":"dp/knapsack/#knapsack_1","text":"Knapsack is a classic problem of DP which revolves around making choices for an element to be taken or not. We will cover the whole knapsack starting from scratch.","title":"Knapsack"},{"location":"dp/knapsack/#problem","text":"You are given an array $W$ of $n$ numbers representing weights of objects. You have to compute whether it is possible to make target weight $K$ from the given weights. A naive recursive $O(2^n)$ solution to this problem would be to recurse for all possible subsets of the given weights. bool knapsack ( int index , int n , vector < long long > & W , long long K ) { if ( index >= n ) return K == 0 ; else if ( K == 0 ) return true ; if ( W [ index ] <= K ) { return knapsack ( index + 1 , n , W , K - W [ index ]) | knapsack ( index + 1 , n , W , K ); } else { return knapsack ( index + 1 , n , W , K ); } }","title":"Problem"},{"location":"dp/knapsack/#solution-using-dp","text":"We can observe that using recursion, the same subtree is calculated multiple times. This repetition can be avoided if the results are stored for every state. This is called Memoization . Let's declare a 2D boolean vector $dp[i][j]$ which will store whether it is possible to make target weight $j$ from the first $i$ weights. $$ dp[i][j] = \\begin{cases} 1 &\\text{if possible} \\\\ 0 &\\text{if not} \\end{cases} $$ $$ dp[i][j] = dp[i-1][j-W[i]] | dp[i-1][j] $$","title":"Solution using DP"},{"location":"dp/knapsack/#implementation","text":"The memoization solution $O(n\\times K)$ can be written easily by a few lines of code in the original recursive function. memset ( dp , -1 , sizeof dp ); bool knapsack ( int index , int n , vector < long long > & W , long long K ) { if ( index >= n ) return K == 0 ; else if ( K == 0 ) return true ; if ( dp [ index ][ K ] != -1 ) return dp [ index ][ K ]; if ( W [ index ] <= K ) { return dp [ index ][ K ] = knapsack ( index + 1 , n , W , K - W [ index ]) | knapsack ( index + 1 , n , W , K ); } else { return dp [ index ][ K ] = knapsack ( index + 1 , n , W , K ); } } Another approach for DP is the iterative approach. bool dp [ n + 1 ][ K + 1 ]; long long knapsack ( int n , long long K , vector < long long > & W ) { dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( j >= W [ i ]) { dp [ i ][ j ] = dp [ i -1 ][ j ] | dp [ i -1 ][ j - W [ i ]]; } else { dp [ i ][ j ] = dp [ i -1 ][ j ]; } } } }","title":"Implementation"},{"location":"dp/knapsack/#extended-problems","text":"What if every object has a value $V_i$ associated to it and your task is to maximize the value? Solve if $K$ target may not have to be fullfilled while maximizing the value. Now if the target weight always be only a multiple of $K$ , then finad the maximum sum of values.","title":"Extended Problems"},{"location":"dp/knapsack/#practice-problems","text":"Atcoder - Frog CSES - Book Shop Atcoder - Vacations Codeforces - Boredom","title":"Practice Problems"},{"location":"dp/lis_lcs/","text":"LIS and LCS A subsequence of a given sequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements reference - wikipedia Longest Increasing Subsequence Problem You are given a sequence of $n$ integers and you task is to find the length of the longest increasing subsequence from the given sequence array. Solution We can see that if we are somehow told the longest length ending at a particular index, then we can tell the answer in $O(n)$ by finding the maximum of all the lengths. We will calculate the above told array using a $dp[i]$ which will tell the longest length ending at index $i$ . Implementation int dp [ n ]; int LIS ( int n , vector < long long > & arr ) { memset ( dp , 1 , sizeof dp ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i -1 ; j >= 0 ; j -- ) { if ( arr [ j ] <= arr [ i ]) { dp [ i ] = max ( dp [ i ], 1 + dp [ j ]); } } } int ans = 1 ; for ( auto x : dp ) ans = max ( ans , x ); return ans ; } Longest Common Subsequence Problem You are given two sequences $a$ and $b$ and your task is to tell from all the common subsequences from them, what is the length of the longest common subsequence. Solution A $dp[i][j]$ will store the maximum length of the common subsequence upto the $ith$ index of $a$ and $jth$ index of $b$ . If we are at this state, we can move to another by just checking the corresponding characters in both sequences. If the characters at the indices in both sequences are same, then the length can be increased by 1 and the corresponding length upto the previous indices be added. Implementation int dp [ n + 1 ][ m + 1 ]; int LCS ( string a , int n , string b , int m ) { memset ( dp , 0 , sizeof dp ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i -1 ] == b [ j -1 ]) { dp [ i ][ j ] = 1 + dp [ i -1 ][ j -1 ]; } dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j ]); dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ j -1 ]); } } return dp [ n ][ m ]; } Practice Problems Codeforces - Palindrome Leetcode - Longest Common Subequence Leetcode - Longest Increasing Subequence Leetcode - Longest Palindromic Subequence","title":"LIS and LCS"},{"location":"dp/lis_lcs/#lis-and-lcs","text":"A subsequence of a given sequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements reference - wikipedia","title":"LIS and LCS"},{"location":"dp/lis_lcs/#longest-increasing-subsequence","text":"","title":"Longest Increasing Subsequence"},{"location":"dp/lis_lcs/#problem","text":"You are given a sequence of $n$ integers and you task is to find the length of the longest increasing subsequence from the given sequence array.","title":"Problem"},{"location":"dp/lis_lcs/#solution","text":"We can see that if we are somehow told the longest length ending at a particular index, then we can tell the answer in $O(n)$ by finding the maximum of all the lengths. We will calculate the above told array using a $dp[i]$ which will tell the longest length ending at index $i$ .","title":"Solution"},{"location":"dp/lis_lcs/#implementation","text":"int dp [ n ]; int LIS ( int n , vector < long long > & arr ) { memset ( dp , 1 , sizeof dp ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i -1 ; j >= 0 ; j -- ) { if ( arr [ j ] <= arr [ i ]) { dp [ i ] = max ( dp [ i ], 1 + dp [ j ]); } } } int ans = 1 ; for ( auto x : dp ) ans = max ( ans , x ); return ans ; }","title":"Implementation"},{"location":"dp/lis_lcs/#longest-common-subsequence","text":"","title":"Longest Common Subsequence"},{"location":"dp/lis_lcs/#problem_1","text":"You are given two sequences $a$ and $b$ and your task is to tell from all the common subsequences from them, what is the length of the longest common subsequence.","title":"Problem"},{"location":"dp/lis_lcs/#solution_1","text":"A $dp[i][j]$ will store the maximum length of the common subsequence upto the $ith$ index of $a$ and $jth$ index of $b$ . If we are at this state, we can move to another by just checking the corresponding characters in both sequences. If the characters at the indices in both sequences are same, then the length can be increased by 1 and the corresponding length upto the previous indices be added.","title":"Solution"},{"location":"dp/lis_lcs/#implementation_1","text":"int dp [ n + 1 ][ m + 1 ]; int LCS ( string a , int n , string b , int m ) { memset ( dp , 0 , sizeof dp ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i -1 ] == b [ j -1 ]) { dp [ i ][ j ] = 1 + dp [ i -1 ][ j -1 ]; } dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j ]); dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ j -1 ]); } } return dp [ n ][ m ]; }","title":"Implementation"},{"location":"dp/lis_lcs/#practice-problems","text":"Codeforces - Palindrome Leetcode - Longest Common Subequence Leetcode - Longest Increasing Subequence Leetcode - Longest Palindromic Subequence","title":"Practice Problems"},{"location":"number_theory/basics/","text":"Number Theory Basics Modulus Operation % is an operator which is frequently used in number theory. It stands for the remainder in CS theory. Examples - $5 \\% 2 = 1$ $23 \\% 8 = 7$ The value of a modular operation can lie in the range $0$ to $m-1$ $i.e.$ $$ 0 \\le a(\\bmod m) \\le m-1 $$ Generally, in competitive programming problems, value of $m$ is given as $10^9+7$ or $998,244,353$ , which are two big prime numbers. Modular Arithmetic $(a + b)\\% m = (a\\% m + b\\% m) \\% m$ $(a - b)\\% m = (a\\% m - b\\% m + m) \\% m$ $(a \\times b)\\% m = (a\\% m \\times b\\% m) \\% m$ $(\\frac a b)\\% m = (a\\% m \\times b^{-1}\\% m) \\% m$ (We will cover the modular inverse shortly) Euler Totient Function $\\phi(n)$ = # of numbers from $1$ to $n$ which are coprime to n. The formula for calculating this was given by Euler $i.e.$ $$ \\phi(n) = n\\left(1 -\\frac 1 p_1\\right)\\left(1 -\\frac 1 p_2\\right)\\left(1 -\\frac 1 p_3\\right) ... $$ Euler's Theorem $$ a^{\\phi(m)} \\equiv 1 \\pmod m $$ If we multiply both sides by $a^{-1}$ we will get $$ a^{\\phi(m) - 1} \\equiv a^{-1} \\pmod m $$ According to Euler Totient function definition, if the number $m$ is taken a prime(which is the case most of the time in competitive programming), then the $\\phi(n)$ becomes $m-1$ therefore the modular inverse of any number may be calculated as $$ a^{-1} \\equiv a^{m-2} \\pmod m $$ The exponent $(m-2)$ can be huge $O(10^9)$ in CP problems so we will use a teqnique called Binary Exponentiation to calculate the modular exponents efficiently. Corollary: Since if $m$ is odd, then the exponent can be reduced by the Euler's Theorem to $(m-2) \\pmod {m-1}$ . The proof of same is out of the scope of this article. $$ a^{-1} \\equiv a^{m-2 \\pmod {m-1}} \\pmod m $$ Practice Problems Codechef - Chef and Riffles","title":"Basics"},{"location":"number_theory/basics/#number-theory-basics","text":"","title":"Number Theory Basics"},{"location":"number_theory/basics/#modulus-operation","text":"% is an operator which is frequently used in number theory. It stands for the remainder in CS theory. Examples - $5 \\% 2 = 1$ $23 \\% 8 = 7$ The value of a modular operation can lie in the range $0$ to $m-1$ $i.e.$ $$ 0 \\le a(\\bmod m) \\le m-1 $$ Generally, in competitive programming problems, value of $m$ is given as $10^9+7$ or $998,244,353$ , which are two big prime numbers.","title":"Modulus Operation"},{"location":"number_theory/basics/#modular-arithmetic","text":"$(a + b)\\% m = (a\\% m + b\\% m) \\% m$ $(a - b)\\% m = (a\\% m - b\\% m + m) \\% m$ $(a \\times b)\\% m = (a\\% m \\times b\\% m) \\% m$ $(\\frac a b)\\% m = (a\\% m \\times b^{-1}\\% m) \\% m$ (We will cover the modular inverse shortly)","title":"Modular Arithmetic"},{"location":"number_theory/basics/#euler-totient-function","text":"$\\phi(n)$ = # of numbers from $1$ to $n$ which are coprime to n. The formula for calculating this was given by Euler $i.e.$ $$ \\phi(n) = n\\left(1 -\\frac 1 p_1\\right)\\left(1 -\\frac 1 p_2\\right)\\left(1 -\\frac 1 p_3\\right) ... $$","title":"Euler Totient Function"},{"location":"number_theory/basics/#eulers-theorem","text":"$$ a^{\\phi(m)} \\equiv 1 \\pmod m $$ If we multiply both sides by $a^{-1}$ we will get $$ a^{\\phi(m) - 1} \\equiv a^{-1} \\pmod m $$ According to Euler Totient function definition, if the number $m$ is taken a prime(which is the case most of the time in competitive programming), then the $\\phi(n)$ becomes $m-1$ therefore the modular inverse of any number may be calculated as $$ a^{-1} \\equiv a^{m-2} \\pmod m $$ The exponent $(m-2)$ can be huge $O(10^9)$ in CP problems so we will use a teqnique called Binary Exponentiation to calculate the modular exponents efficiently. Corollary: Since if $m$ is odd, then the exponent can be reduced by the Euler's Theorem to $(m-2) \\pmod {m-1}$ . The proof of same is out of the scope of this article. $$ a^{-1} \\equiv a^{m-2 \\pmod {m-1}} \\pmod m $$","title":"Euler's Theorem"},{"location":"number_theory/basics/#practice-problems","text":"Codechef - Chef and Riffles","title":"Practice Problems"},{"location":"number_theory/binpow/","text":"Binary Exponentiation Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate \u200a $a^n$ \u200a using only \u200a $O(\\log n)$ \u200a multiplications (instead of \u200a $O(n)$ \u200a multiplications required by the naive approach). Algorithm Raising \u200a $a$ \u200a to the power of \u200a $n$ \u200a is expressed naively as multiplication by \u200a $a$ \u200a done \u200a $n - 1$ \u200a times: \u200a $a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$ \u200a. However, this approach is not practical for large \u200a $a$ \u200a or \u200a $n$ \u200a. The idea of binary exponentiation is, that we split the work using the binary representation of the exponent. Let's write $n$ in base 2, for example: $$ \\begin{align} \\notag a^{13} &= a^{1101_2} \\\\ \\notag &= a^{1000_2} \\cdot a^{100_2} \\cdot a^{0_2} \\cdot a^{1_2} \\\\ \\notag &= a^8 \\cdot a^4 \\cdot a^1 \\end{align} $$ For example, with $a = 3$ $$\\begin{align} \\notag 3^1 &= 3 \\\\ \\notag 3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ \\notag 3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ \\notag 3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$$ So to get the final answer for \u200a $3^{13}$ \u200a, we only need to multiply three of them (skipping \u200a $3^2$ \u200a because the corresponding bit in \u200a $n$ \u200a is not set): \u200a $3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$ \u200a The final complexity of this algorithm is \u200a $O(\\log n)$ \u200a: we have to compute \u200a $\\log n$ \u200a powers of \u200a $a$ \u200a, and then have to do at most \u200a $\\log n$ \u200a multiplications to get the final answer from them. The following recursive approach expresses the same idea: $$ a^n = \\begin{cases} 1 &\\text{if } n == 0 \\\\ \\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even} \\\\ \\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd} \\\\ \\end{cases} $$ Implementation The recursive approach is the direct translation of the formula above. long long binpow ( long long a , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( a , n / 2 ); if ( b % 2 == 0 ) return res * res ; else return res * res * a ; } The second approach accomplishes the same task without recursion. It computes all the powers in a loop, and multiplies the ones with the corresponding set bit in \u200a $n$ \u200a. Although the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls. It uses the fact that everytime in a loop we are squaring the powers, and when there is $1$ in binary representation of $n$ ( $i.e.$ if n becomes odd at some moment after continuous division) we multiply by an extra $a$ . long long binpow ( long long a , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * a ; a = a * a ; n >>= 1 ; } return res ; } Applications Effective computation of large exponents modulo m Many times we need not compute the exact exponents rather the problem demands us to compute a large power (often, a big prime number) and to do it we can use binary exponentiation with a slight change reflected in the code below. long long binpow ( long long a , long long n , long long m ) { a %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * a % m ; a = a * a % m ; n >>= 1 ; } return res ; } Multiplication of two numbers modulo m If we need to calculate multiplication of two very large numbers which themselves can fit in long long data types but their product cannot, then we can modify the binary exponentiation to compute it modulo $m$ within range. The idea is to break any of the two numbers into binary and instead of doing exponent, this time we need to multiply with that number. For exmample: $$ \\begin{align} \\notag a \\cdot 13 &= a \\cdot 1101_2 \\\\ \\notag &= {a \\cdot 1000_2} + {a \\cdot 100_2} + {a \\cdot 0_2} + {a \\cdot 1_2} \\\\ \\notag &= {a \\cdot 8} + {a \\cdot 4} + {a \\cdot 1} \\end{align} $$ We can note by the above example that we are adding to our $ans$ whenever there is a $set$ bit present in binary of $b$ . The recursive formula for the above idea can be framed as: $$ a \\cdot b = \\begin{cases} 0 &\\text{if } b = 0 \\ 2 \\cdot a \\cdot \\frac{b}{2} &\\text{if }b > 0 \\text{ and }b \\text{ even} \\ 2 \\cdot a \\cdot \\frac{b-1}{2} + a &\\text{if }b > 0 \\text{ and }b \\text{ odd} \\end{cases} $$\u200a The same code for the binary exponentiation can be reused with some slight modifications: long long modmul ( long long a , long long b , long long m ) { a %= m ; b %= m ; long long res = 0 ; while ( b > 0 ) { if ( b & 1 ) res = res + a % m ; a = 2 * a % m ; b >>= 1 ; } return res ; } Pratice Problems Codeforces - Parking Lot SPOJ - The last digit SPOJ - Magic of the locker SPOJ - Just add it References cp-algorithms - Binary Exponentiation GFG - Modular Multiplication","title":"Binary Exponentiation"},{"location":"number_theory/binpow/#binary-exponentiation","text":"Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate \u200a $a^n$ \u200a using only \u200a $O(\\log n)$ \u200a multiplications (instead of \u200a $O(n)$ \u200a multiplications required by the naive approach).","title":"Binary Exponentiation"},{"location":"number_theory/binpow/#algorithm","text":"Raising \u200a $a$ \u200a to the power of \u200a $n$ \u200a is expressed naively as multiplication by \u200a $a$ \u200a done \u200a $n - 1$ \u200a times: \u200a $a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$ \u200a. However, this approach is not practical for large \u200a $a$ \u200a or \u200a $n$ \u200a. The idea of binary exponentiation is, that we split the work using the binary representation of the exponent. Let's write $n$ in base 2, for example: $$ \\begin{align} \\notag a^{13} &= a^{1101_2} \\\\ \\notag &= a^{1000_2} \\cdot a^{100_2} \\cdot a^{0_2} \\cdot a^{1_2} \\\\ \\notag &= a^8 \\cdot a^4 \\cdot a^1 \\end{align} $$ For example, with $a = 3$ $$\\begin{align} \\notag 3^1 &= 3 \\\\ \\notag 3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ \\notag 3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ \\notag 3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$$ So to get the final answer for \u200a $3^{13}$ \u200a, we only need to multiply three of them (skipping \u200a $3^2$ \u200a because the corresponding bit in \u200a $n$ \u200a is not set): \u200a $3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$ \u200a The final complexity of this algorithm is \u200a $O(\\log n)$ \u200a: we have to compute \u200a $\\log n$ \u200a powers of \u200a $a$ \u200a, and then have to do at most \u200a $\\log n$ \u200a multiplications to get the final answer from them. The following recursive approach expresses the same idea: $$ a^n = \\begin{cases} 1 &\\text{if } n == 0 \\\\ \\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even} \\\\ \\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd} \\\\ \\end{cases} $$","title":"Algorithm"},{"location":"number_theory/binpow/#implementation","text":"The recursive approach is the direct translation of the formula above. long long binpow ( long long a , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( a , n / 2 ); if ( b % 2 == 0 ) return res * res ; else return res * res * a ; } The second approach accomplishes the same task without recursion. It computes all the powers in a loop, and multiplies the ones with the corresponding set bit in \u200a $n$ \u200a. Although the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls. It uses the fact that everytime in a loop we are squaring the powers, and when there is $1$ in binary representation of $n$ ( $i.e.$ if n becomes odd at some moment after continuous division) we multiply by an extra $a$ . long long binpow ( long long a , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * a ; a = a * a ; n >>= 1 ; } return res ; }","title":"Implementation"},{"location":"number_theory/binpow/#applications","text":"","title":"Applications"},{"location":"number_theory/binpow/#effective-computation-of-large-exponents-modulo-m","text":"Many times we need not compute the exact exponents rather the problem demands us to compute a large power (often, a big prime number) and to do it we can use binary exponentiation with a slight change reflected in the code below. long long binpow ( long long a , long long n , long long m ) { a %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * a % m ; a = a * a % m ; n >>= 1 ; } return res ; }","title":"Effective computation of large exponents modulo m"},{"location":"number_theory/binpow/#multiplication-of-two-numbers-modulo-m","text":"If we need to calculate multiplication of two very large numbers which themselves can fit in long long data types but their product cannot, then we can modify the binary exponentiation to compute it modulo $m$ within range. The idea is to break any of the two numbers into binary and instead of doing exponent, this time we need to multiply with that number. For exmample: $$ \\begin{align} \\notag a \\cdot 13 &= a \\cdot 1101_2 \\\\ \\notag &= {a \\cdot 1000_2} + {a \\cdot 100_2} + {a \\cdot 0_2} + {a \\cdot 1_2} \\\\ \\notag &= {a \\cdot 8} + {a \\cdot 4} + {a \\cdot 1} \\end{align} $$ We can note by the above example that we are adding to our $ans$ whenever there is a $set$ bit present in binary of $b$ . The recursive formula for the above idea can be framed as: $$ a \\cdot b = \\begin{cases} 0 &\\text{if } b = 0 \\ 2 \\cdot a \\cdot \\frac{b}{2} &\\text{if }b > 0 \\text{ and }b \\text{ even} \\ 2 \\cdot a \\cdot \\frac{b-1}{2} + a &\\text{if }b > 0 \\text{ and }b \\text{ odd} \\end{cases} $$\u200a The same code for the binary exponentiation can be reused with some slight modifications: long long modmul ( long long a , long long b , long long m ) { a %= m ; b %= m ; long long res = 0 ; while ( b > 0 ) { if ( b & 1 ) res = res + a % m ; a = 2 * a % m ; b >>= 1 ; } return res ; }","title":"Multiplication of two numbers modulo m"},{"location":"number_theory/binpow/#pratice-problems","text":"Codeforces - Parking Lot SPOJ - The last digit SPOJ - Magic of the locker SPOJ - Just add it","title":"Pratice Problems"},{"location":"number_theory/binpow/#references","text":"cp-algorithms - Binary Exponentiation GFG - Modular Multiplication","title":"References"}]}